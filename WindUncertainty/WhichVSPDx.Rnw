%% LyX 2.1.1 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[12pt]{report}
\usepackage{mathptmx}
\usepackage[T1]{fontenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=3.54cm,bmargin=2.54cm,lmargin=2.54cm,rmargin=2.54cm,headheight=1cm,headsep=2cm,footskip=0.5cm}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{verbatim}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\input colordvi
\usepackage{color}
\fancyhead{}
\fancyfoot[CE,CO]{}
\newtoks{\topicofnote} \global\topicofnote={}
\newdimen\longindent \longindent=3.5truein
\fancyhead[L]{Aircraft Algorithm Memo re: \the\topicofnote \\ \datetoday \\ Page \thepage \hfill}
\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\RAFAlgorithmMemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Research Aviation Facility}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Algorithm Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.2truein\leftline{\textcolor{blue}{\textsf{Subject: \the\topicofnote}}}
\leftline{\textcolor{blue}{\textsf{Al Cooper}}}
\leftline{\textcolor{blue}{\textsf{\datetoday}}} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lyxlist}{Attachments:00}
\item [Attachments:] {#1}
\end{lyxlist}}
\newcommand{\cc}[1]{\begin{lyxlist}{Attachments:00}
\item [cc:] {#1}
\end{lyxlist}}
\newcommand{\attach}[1]{\begin{lyxlist}{Attachments:00}
\item [Attachment:] {#1}
\end{lyxlist}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}

\makeatother

\begin{document}
\begin{comment}
set topicofnote to topic of note
\end{comment}


\topicofnote={VSPD for reprocessing of projects before OMNISTAR was available}

\RAFAlgorithmMemo


\section*{Background}

Two questions are addressed in this memo:
\begin{enumerate}
\item Which variable or combination of variables should be used to represent
the vertical motion of the aircraft in vertical-wind calculations?
\item What is the time delay that should be used with that variable?
\end{enumerate}

\section*{Present Processing Code}

As originally processed, many projects used VSPD\_G or GVSPD\_A or
VSPD\_A, all called the ``Avionics GPS Vertical Velocity'', as the
variable entering calculation of WIC, the vertical wind. Furthermore,
calibration coefficients were often used to modify this variable from
what was reported by the avionic system. For example, for HIPPO-4
the files were processed with these calibration coefficients (taken
from the netCDF files): -0.06f, 1.02f. It is hard to understand why
this measurement, based on GPS, should need adjustment or calibration.
As used in HIPPO-4, the measurement was further adjusted by an assumed
time lag of -500~ms. This variable is recorded at a sample rate of
50~Hz in HIPPO-4 but only 1 Hz in CONTRAST. In the latter experiment
(where the variable name was GVSPD\_A), a time lag of -1~s was applied
in processing, but there was no calibration adjustment. For CONTRAST,
the choice of variable to use is GGVSPDB because OMNISTAR-quality
measurements were often available, so this experiment provides some
ability to compare the other measures of vertical aircraft speed to
the reference OMNISTAR-adjusted measurements.


\section*{Reasons For Proposing Changes}


\section*{Analysis}

One important aspect to consider is the spectral response of these
different signals. CONTRAST provides good opportunities to evaluate
this response because there were some periods of moderate turbulence
in clouds, so that experiment will be used for this assessment. A
good candidate is flight 14, 7:23--7:28, a fairly turbulent period
of in-cloud flight. These variables are relevant to this study:

\noindent \begin{center}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{Variable} & \textbf{Description} & \textbf{Comments}\tabularnewline
\hline 
\hline 
VSPD & IRS Vertical Speed & 25 Hz, sampled at 50 Hz, -50 ms lag, reduncant VSPD\_IRS2\tabularnewline
\hline 
GVSPD\_A & Avionics GPS Vertical Velocity & sampled at 1 Hz, no shift in reprocessed file\tabularnewline
\hline 
GGVSPDB & Reference GPS Vertical Speed & sampled at 5 Hz, output at 1 Hz, no shift in reprocessed file\tabularnewline
\hline 
WIC & GPS-Corrected Wind Vector, Vertical Gust Component & derived using GGVSPDB; 25 Hz\tabularnewline
\hline 
GUSTW & Relative wind vertical component & special processing, 25 Hz\tabularnewline
\hline 
WIX & Wind, Vertical Component & special processing, 25 Hz\tabularnewline
\hline 
\end{tabular}
\par\end{center}

Because GVSPD\_A and GGVSPDB are recorded at 1 Hz even in the high-rate
file, these were recalculated in a special processing step that applied
interpolation and filtering to obtain a 25-Hz measurement. That special
processing step also calculated another vertical-wind variable, WIX,
by application of the PCORS and sensitivity coefficients determined
after the project for CONTRAST, and it also saved the relative-wind
contribution to WIC or WIX in the variable GUSTW.

<<Initialization,echo=FALSE,include=FALSE>>=

require(Ranadu)
require(signal)
library(knitr)
Flight <- "rf14hrt"
Directory <- "/home/Data/"
Project <- "CONTRAST"
fname = sprintf("%s%s/CONTRAST%s.nc", Directory, Project,Flight)
# copy to a new file before adding variables to it:
fnew = sprintf("%s%s/CST%s_x.nc", Directory, Project,Flight)
system(paste ("cp", fname, fnew, sep=' '), wait=TRUE)
VarNames <- c("VYC","GGALT","LATC", "LONC", "PSXC", "QCXC",
              "WDC", "WSC", "GGVEW", "GGVNS", "VEW", "VNS",
              "ADIFR", "AKRD", "SSLIP", "PITCH", "TASX",
              "ROLL", "THDG", "BDIFR", "EWX", "GGVSPDB", "WIC",
              "VSPD", "GVSPD_A", "ATX", "PSF", "QCF", "GGVEWB", "GGVNSB")
Data <- getNetCDF (fname, VarNames) # high-rate data OK here
Cradeg <- pi / 180.
# get rid of lines where any variable is NA (esp. causes filter problems):
# No, can't do this; creates problems with alignment of data already in netCDF file
#Data <- na.omit(Data)

<<Relative-Wind-Code,echo=FALSE,include=FALSE>>=

attach(Data)    # get the unrestricted full data file
AQR <- ADIFR / QCXC
RR <- QCXC/PSXC
Mach <- MachNumber (PSXC, QCXC)
#AQR_GP <- ADIFR_GP/QC_GP
#RR_GP <- QC_GP/PS_GP
# # use coefficients saved from WindUncertainty.Rnw; revise for projects other than DEEPWAVE
# #cf_GP <- c(-0.9151291, 3.9277735, 3.1905422, 1.3502541)
# cf_GP <- c(-0.9168, 3.918, 3.2505, 1.3531)
cfr <- c(4.4554, 21.4007)    	# DEEPWAVE
cfr <- c(4.338, 20.982)		  # CONTRAST
AOA <- cfr[1] + AQR * cfr[2] 
#AOA_GP <- cf_GP[1] + AQR_GP * (cf_GP[2] + cf_GP[3]*Mach) + cf_GP[4]*RR_GP
cfs <- c(0., 21.335) 
cfs <- c(0.016, 21.9915)
#cfs_GP <- c(-3.498, 11.443)
#cfs_GP <- c(-3.6091, 12.138)
SS <- cfs[1] + cfs[2] * BDIFR / QCXC
#SS_GP <- cfs_GP[1] + cfs_GP[2] * BDIFR_GP / QC_GP
bf <- c(-0.07791, -1.1571, 2.6691, -1.3588, -0.0046686, 0.53110)
#RRS_GP <- QC_GP / PS_GP
#RRS <- bf[1] + RRS_GP * (bf[2] + bf[3] * Mach + bf[4] * RRS_GP) + bf[5] * ADIFR_GP / QC_GP + bf[6] * Mach
# note that PSXC in the next equation doesn't matter, only the ratio RRS
#TAS_GP <- TrueAirspeed (MachNumber (PSXC, PSXC*RRS), ATX)

# before using TASX, apply PCOR corrections:
# (skipping; should have already been done in reprocessing Sept 2014)
#DeltaP <- PCorFunction (PSF, QCF, ADIFR, qcr=QCF, bcoef=c(cfr[1], cfr[2], 0.), AC="GV")
#PSXC <- PSF + DeltaP
#QCXC <- QCF - DeltaP
Mach <- MachNumber (PSXC, QCXC, EWX)
TASX <- TrueAirspeed (Mach, ATX, EWX/PSXC)

# # define a dataframe for the relative wind from the gust pod:
# d <- data.frame("U_RW"=TASX)   #use TASX instead of TAS_GP for lower-uncertainty components
# d["V_RW"] <- TASX * tan (SS_GP * Cradeg)
# d["W_RW"] <- TASX * tan (AOA_GP * Cradeg)

d2 <- data.frame ("U2"=TASX)
d2["V2"] <- TASX * tan (SS * Cradeg)
d2["W2"] <- TASX * tan (AOA * Cradeg)

<<Rotation-matrices,echo=FALSE>>=

rw2 <- as.matrix(d2)
cosphi2 <- cos (ROLL * Cradeg)
sinphi2 <- sin (ROLL * Cradeg)
costheta2 <- cos (PITCH * Cradeg)
sintheta2 <- sin (PITCH * Cradeg)
cospsi2 <- cos (THDG * Cradeg)
sinpsi2 <- sin (THDG * Cradeg)
DL <- length(TASX)
One <- rep (1, DL)
Z <- rep (0, DL)
TT1 <- aperm(array (c(One,Z,Z,Z,cosphi2,-sinphi2,Z,sinphi2,cosphi2), 
                    dim=c(DL,3,3)))
TT2 <- aperm(array (c (costheta2,Z,sintheta2,Z,One,Z,-sintheta2,Z,costheta2), 
                    dim=c(DL,3,3)))
TT3 <- aperm(array (c (cospsi2,-sinpsi2,Z,sinpsi2,cospsi2,Z,Z,Z,One), 
                    dim=c(DL,3,3)))
<<Calculate-new-wind-variables-WDG-WSG-WIG,echo=FALSE>>=

WDX <- vector ("numeric", DL)
WSX <- vector ("numeric", DL)
WIX <- vector ("numeric", DL)
GUSTW <- vector ("numeric", DL)
GUSTA <- vector ("numeric", DL)  # special test, V*AKRD*Cradeg
GUSTB <- vector ("numeric", DL)  # special test, V*PITCH*Cradeg
# to avoid problems with filtering NA, reset them to zero:
VEW[is.na(VEW)] <- 0.
VNS[is.na(VNS)] <- 0.
GGVEW[is.na(GGVEW)] <- 0.
GGVNS[is.na(GGVNS)] <- 0.
VEWC <- ComplementaryFilter (VEW, GGVEWB, 150.)  # repeat this to remove old-filter bias
VNSC <- ComplementaryFilter (VNS, GGVNSB, 150.)
Hlast <- 0.
# note: tried e.g. tensor (aperm(T1), rw, 2, 2) -- fails
#       because of size of vector that it tries to allocate
# This works, though:
# Y1t <- mapply(FUN="%*%", lapply(X=apply(aperm(T1), 3, as.data.frame), FUN=as.matrix, nrow=3, ncol=3), as.data.frame(aperm(rw)))
# etc.
# There may be a better way, though
# apply(T1, 3, as.data.frame) produces a list, DL long, of
# 3x3 dataframes. lapply() converts that dataframe to a matrix
# and then mapply multiplies rw by the matrix.
# However, the loop below is fast (typically <1 s) and the
# following attempt to vectorize takes more than 10 times
# as long, so this is left commented for reference.
# system.time(
# {Y1 <- mapply(FUN="%*%", lapply(X=apply(T1, 3, as.data.frame), FUN=as.matrix, nrow=3, ncol=3), as.data.frame(aperm(rw)))
# Y2 <- mapply(FUN="%*%", lapply(X=apply(T2, 3, as.data.frame), FUN=as.matrix, nrow=3, ncol=3), as.data.frame(Y1))
# Y3 <- mapply(FUN="%*%", lapply(X=apply(T3, 3, as.data.frame), FUN=as.matrix, nrow=3, ncol=3), as.data.frame(Y2))
# WG <- aperm(matrix (c(-CVNS_GP, -CVEW_GP, CVSPD_GP), DL, 3))
# Y4 <- Y3 + WG
# WDG <- atan2 (Y4[2,], Y4[1,]) / Cradeg
# WSG <- sqrt (Y4[1,]**2 + Y4[2,]**2)
# WIG <- Y4[3,]
# WDG[!is.na(WDG) & (WDG < 0.)] <- WDG[!is.na(WDG) & (WDG < 0.)] + 360.
# }) 
# here is the loop equivalent:
for (i in 1:DL) {
  Y1 <- TT1[,,i] %*% matrix (rw2[i,], 3, 1)
  Y2 <- TT2[,,i] %*% Y1
  Y3 <- TT3[,,i] %*% Y2
  WG <- matrix (c(-VNSC[i], -VEWC[i], GGVSPDB[i]), 
                3, 1)
  Y4 <- Y3 + WG
  WDX[i] <- atan2 (Y4[2], Y4[1]) / Cradeg
  if ((!is.na(WDX[i])) & (WDX[i] < 0.)) {
    WDX[i] <- WDX[i] + 360.
  }
  WSX[i] <- sqrt (Y4[1]**2 + Y4[2]**2)
  WIX[i] <- Y4[3]
  GUSTW[i] <- Y3[3]
}
VSPDX <- GGVSPDB
GVSPDX <- GVSPD_A
GUSTA <- TASX * AOA * Cradeg
GUSTB <- TASX * PITCH * Cradeg

<<Add-to-the-netCDF-file,echo=FALSE,include=FALSE>>=
# add new variables to the netCDF file:

netCDFfile <- open.ncdf (fnew, write=TRUE)

if ("sps25" %in% names(netCDFfile$dim)) {
  DLL <- length(TASX)/25
  dim(WIX) <- c(25, DLL)
  dim(WSX) <- c(25, DLL)
  dim(WDX) <- c(25, DLL)
  dim(GUSTW) <- c(25, DLL)
  dim(GUSTA) <- c(25, DLL)
  dim(GUSTB) <- c(25, DLL)
  dim(VSPDX) <- c(25, DLL)
  dim(GVSPDX) <- c(25, DLL)

  varWIX <- var.def.ncdf ("WIX", "m/s", 
            c(netCDFfile$dim["sps25"], 
              netCDFfile$dim["Time"]), -32767.,
            "Vertical wind based on measurements from the radome, revised")
  varWDX <- var.def.ncdf ("WDX", "deg.", 
            c(netCDFfile$dim["sps25"],
              netCDFfile$dim["Time"]), -32767.,
            "Wind direction based on measurements from the radome, revised")
  varWSX <- var.def.ncdf ("WSX", "m/s", 
          c(netCDFfile$dim["sps25"],
            netCDFfile$dim["Time"]), -32767.,
          "Wind speed based on measurements from the radome, revised")
  varGUSTW <- var.def.ncdf ("GUSTW", "m/s", 
                            c(netCDFfile$dim["sps25"],
                              netCDFfile$dim["Time"]),
                          -32767., "Gust component, vertical wind")
  varGUSTA <- var.def.ncdf ("GUSTA", "m/s", 
                            c(netCDFfile$dim["sps25"],
                              netCDFfile$dim["Time"]),
                          -32767., "Gust component A, vertical wind")
  varGUSTB <- var.def.ncdf ("GUSTB", "m/s", 
                            c(netCDFfile$dim["sps25"],
                              netCDFfile$dim["Time"]),
                          -32767., "Gust component B, vertical wind")
  varVSPDX <- var.def.ncdf ("VSPDX", "m/s", 
                            c(netCDFfile$dim["sps25"],
                              netCDFfile$dim["Time"]),
                          -32767., "Aircraft vertical speed. filtered")
  varGVSPDX <- var.def.ncdf ("GVSPDX", "m/s", 
                            c(netCDFfile$dim["sps25"],
                              netCDFfile$dim["Time"]),
                          -32767., "Avionics vertical speed. filtered")
} else {
  varWIX <- var.def.ncdf ("WIX", "m/s", 
            netCDFfile$dim["Time"], -32767.,
            "Vertical wind based on measurements from the radome, revised")
  varWDX <- var.def.ncdf ("WDX", "deg.", 
            netCDFfile$dim["Time"], -32767.,
            "Wind direction based on measurements from the radome, revised")
  varWSX <- var.def.ncdf ("WSX", "m/s", 
          netCDFfile$dim["Time"], -32767.,
          "Wind speed based on measurements from the radome, revised") 
    varGUSTW <- var.def.ncdf ("GUSTW", "m/s", 
          netCDFfile$dim["Time"], -32767.,
          "Gust component, vertical wind") 
    varGUSTA <- var.def.ncdf ("GUSTA", "m/s", 
          netCDFfile$dim["Time"], -32767.,
          "Gust component A, vertical wind") 
    varGUSTB <- var.def.ncdf ("GUSTB", "m/s", 
          netCDFfile$dim["Time"], -32767.,
          "Gust component B, vertical wind")  
    varVSPDX <- var.def.ncdf ("VSPDX", "m/s", 
          netCDFfile$dim["Time"], -32767.,
          "Aircraft vertical speed, GPS") 
    varGVSPDX <- var.def.ncdf ("GVSPDX", "m/s", 
          netCDFfile$dim["Time"], -32767.,
          "Avionics vertical speed, GPS") 
}
# Later may want to add code here to modify values of TASX to give new results. 
# Not used here, though, so not needed yet.
newfile <- var.add.ncdf (netCDFfile, varWIX)
newfile <- var.add.ncdf (newfile, varWDX)
newfile <- var.add.ncdf (newfile, varWSX)
newfile <- var.add.ncdf (newfile, varGUSTW)
newfile <- var.add.ncdf (newfile, varGUSTA)
newfile <- var.add.ncdf (newfile, varGUSTB)
newfile <- var.add.ncdf (newfile, varVSPDX)
newfile <- var.add.ncdf (newfile, varGVSPDX)
put.var.ncdf (newfile, "WIX", WIX)
put.var.ncdf (newfile, "WDX", WDX)
put.var.ncdf (newfile, "WSX", WSX)
put.var.ncdf (newfile, "GUSTW", GUSTW)
put.var.ncdf (newfile, "GUSTA", GUSTA)
put.var.ncdf (newfile, "GUSTB", GUSTB)
put.var.ncdf (newfile, "VSPDX", VSPDX)
put.var.ncdf (newfile, "GVSPDX", GVSPDX)
close.ncdf (newfile)

detach(Data)

@


\section*{\emph{Recommendations}}

\vskip0.5truein \centerline{\textcolor{blue}{---- END ----}}

%\attach{attachment}

%\attachm{first\\second}

%\cc{first attachment\\second\\3rd att}
\end{document}
